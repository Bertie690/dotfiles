#!/usr/bin/env bash

# Bootstrap script to create symlinks to necessary files inside various directories.
# Sourced from https://github.com/holman/dotfiles/blob/master/script/bootstrap
# with ~~a bit~~ A LOT of tweaking.

# Crash program if something returns with a non-0 exitcode or if a user-specified glob fails to match anything.
set -e
shopt -s failglob
shopt -s dotglob
shopt -s globstar

# Go to dotfiles root
cd "$(dirname "${BASH_SOURCE[0]}")/.."
DOTFILES_ROOT=$(pwd -P)

# An associative array holding all files we've already seen, used to prevent duplicate symlinks.
declare -A seen_files

# Grab all variables and functions defined in our config files.
if [[ -r scripts/utils.sh && -f scripts/utils.sh ]]; then
    source scripts/utils.sh
else
    printf "File utils.sh was not found during initialization!\n" >&2;
    exit 1
fi

if [[ -r scripts/bootstrap_config.sh && -f scripts/bootstrap_config.sh ]]; then
    source scripts/bootstrap_config.sh
else
    quit "File bootstrap_config.sh was not found during initialization!";
fi

# A globally selected option applying to the rest of the current links ("skip all", etc).
globalAction=''

# Iterate and symlink all files and folders in $sources_to_targets.
run () {
    for src_path in "${sources_order[@]}"; do
        dst_path=~/${sources_to_targets[$src_path]}
        # Trim trailing slashes to make the error messages nicer
        dst_path=${dst_path%/}
        src_path=$DOTFILES_ROOT/$src_path
        recurse_links
    done
}

# Recursively link the contents of $src_path to $dst_path.
recurse_links () {
    info "Symlinking all files from $(orange "$src_path") into $(blue "$dst_path")..."

    # If src_path is not a glob, link it directly to dst_path and call it a day.
    if [[ ! "$src_path" =~ .*/\*\*? ]]; then
        link_files "$src_path" "$dst_path"
        return
    fi

    for source in $src_path; do
        # src_path is a glob, so only match files.
        if [[ -f "$source" ]]; then
            dest="$dst_path"/"$(basename "$source")"
            link_files "$source" "$dest"
        fi
    done
}

# Wrapper function to create a link from $1 to $2.
link_files () {
    # The current file/folder that is being linked.
    local src=$1
    # The target location for the link.
    local dst=$2

    # Skip previously seen files
    if [[ -v seen_files[$src] ]]; then
        return;
    fi

    seen_files[$src]="1"

    # The selected action to take when linking over an existing file.
    # Valid options:
    # "skip": Skips linking file
    # "overwrite": Overwrites file contents
    # "backup": Creates backup of previous file contents
    local action=''

    # Skip files that are already linked
    if [ "$(readlink "$dst")" == "$src" ]; then
        success "$(orange "$src") already linked to $(blue "$dst"), skipping..."
        return;
    fi

    # Check if the destination already exists, linking the file immediately if not found.
    if [[ ! -f "$dst" && ! -d "$dst" && ! -L "$dst" ]]; then
        ln -s "$src" "$dst"
        success "Symlinked $(orange "$src") to $(blue "$dst")!"
        return;
    fi

    # If no prior global action has been specified, prompt the user for what to do.
    if [ -z "$globalAction" ]; then
        prompt_user
    fi

    # Finally, make the link as applicable.
    action=${action:-globalAction}
    do_action
}

# Helper function to prompt the user for a course of action when linking over already existing files.
prompt_user () {
    # Repeatedly prompt until valid answer is given
    while [[ -z "$action" && -z "$globalAction" ]]; do
        user "File already exists: $(blue "$dst")!
Options:
[s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all, [q/Q]uit"
        read -r action
        echo '' # Add a newline

        case "$action" in
            o | overwrite )
                action=overwrite;;
            O | "overwrite all" | overwrite-all )
                globalAction=overwrite;;
            b | backup )
                action=backup;;
            B | "backup all" | backup-all )
                globalAction=backup;;
            s | skip )
                action=skip;;
            S | "Skip all" | "skip-all" )
                globalAction=skip;;
            q | Q | "quit" | "Quit" )
                quit "Quitting process...";;
            * )
                error "Invalid option specified!"
                action=""
                ;;
        esac
    done
}

# Execute the selected option.
do_action () {
    case $action in
        "skip" )
            success "Skipped linking $(orange "$src") to $(blue "$dst")."
            return ;;
        "overwrite" )
            rm -rf "$dst"
            ln -sf "$src" "$dst"
            success "Forcibly linked $(orange "$src") to $(blue "$dst")!";;
        "backup" )
            mv "$dst" "$dst".backup
            ln -s "$src" "$dst"
            success "Backed up $(blue "$dst") to $(green "$dst".backup) and linked successfully!";;
        *) ;;
    esac
}

run
success "DONE!"
