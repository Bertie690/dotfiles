#! /usr/bin/env bash

# File containing shell scripts used by `.gitconfig`.
# Notes: Setting the file to "executable" is recommended.

set -euo pipefail

## Utilities

# Make text orange.
orange () {
    printf "\e[33m%s\e[0m" "$1"
}

# Make text red.
red () {
    printf "\e[31m%s\e[0m" "$1"
}

# Make text green.
green () {
    printf "\e[32m%s\e[0m" "$1"
}

# Make text blue.
blue () {
    printf "\e[34m%s\e[0m" "$1"
}

# Annotate text with a blue [...].
info () {
    printf "[$(blue ...)] %s\n" "$1"
}

# Annotate text with a green [✔].
success () {
    printf "[$(green '✔ ')] %s\n" "$1"
}

# Annotate text with a red [✗].
error () {
	printf "[ $(red '✗') ] %s\n" "$1" >&2
}

## Functions

# Used for the link-ignored git command.
link_ignored() {
	main_worktree=$(dirname "$(git rev-parse --path-format=absolute --git-common-dir)")
	curr_worktree=$(git rev-parse --path-format=absolute --show-toplevel)
	if [ "$#" != 1 ]; then
		echo "Expected 1 argument, but got $#."
		return 1
	fi
	if [ "$curr_worktree" = "$main_worktree" ]; then
		echo "Already in main worktree: $main_worktree"
		return 1
	fi

	(cd "$main_worktree" && git show-ignored "$1") | \
	while IFS= read -r l; do
		src="$curr_worktree/$l"
		dst="$main_worktree/$l"
	    # Skip files that are already linked
		if [ "$(readlink "$src")" = "$dst" ]; then
			info "$(orange "$src") already linked to $(blue "$dst"), skipping..."
			continue;
		fi
	    # Make sure file exists
		if [ ! -f "$dst" ] && [ ! -d "$dst" ] && [ ! -L "$dst" ]; then
			ln -s "$src" "$dst"
			success "Symlinked $(orange "$src") to $(blue "$dst")!"
			return
		fi
		error "Could not symlink $(orange "$src") to $(blue "$dst"); file exists!"
	done
}

# Used for the branches-touched command.
branches_touched() {
	if [ -z "$*" ]; then
		error No files specified!
		return 1
	fi

	default="$(get_default_branch)"
	git branch --format='%(refname:short)' | while read -r branch; do
		# error = changes made = log
		if ! git diff --quiet --merge-base "$default" "$branch" -- "$@"; then
			echo "$branch"
		fi
	done;
}

default_branch=""

# get_default_branch obtains the default branch for either the upstream or origin remotes using string substitution.
# It will cache its result inside the `default_branch` variable if allowed.
get_default_branch() {
	if [ "$default_branch" ]; then
		echo "$default_branch"
		return
	fi

	local remote
	SUPPORTED_REMOTES=(upstream origin)
	for name in "${SUPPORTED_REMOTES[@]}"; do
		if [ -n "$(git config --get remote."$name".url)" ]; then
			remote=$name
			break
		fi
	done

	if [ -z "$remote" ]; then
		error "Current remote is not in supported remotes!\nSupported remotes: ${SUPPORTED_REMOTES[*]}"
		return 1
	fi

	default_branch="$remote"/"$(git remote show "$remote" | sed -n '/HEAD branch/s/.*: //p')"
	echo "$default_branch"
}

COMMAND="$1"
shift
$COMMAND "$@"
