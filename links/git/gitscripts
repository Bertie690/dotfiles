#! /usr/bin/env sh

# File containing shell scripts used by `.gitconfig`.
# Must be run in `sh` as that is the shell Git uses to execute things
# Notes: Setting the file to "executable" is recommended.

## Helpers

# Make text orange.
orange () {
    printf "\e[33m%s\e[0m" "$1"
}

# Make text red.
red () {
    printf "\e[31m%s\e[0m" "$1"
}

# Make text green.
green () {
    printf "\e[32m%s\e[0m" "$1"
}

# Make text blue.
blue () {
    printf "\e[34m%s\e[0m" "$1"
}

# Annotate text with a blue [...].
info () {
    printf "[$(blue ...)] %s\n" "$1"
}

# Annotate text with a green [✔].
success () {
    printf "[$(green '✔ ')] %s\n" "$1"
}

# Annotate text with a red [✗].
error () {
	printf "[ $(red '✗') ] %s\n" "$1"
}

## Functions

# Used for the link-ignored git command.
link_ignored() {
	main_worktree=$(dirname "$(git rev-parse --path-format=absolute --git-common-dir)")
	curr_worktree=$(git rev-parse --path-format=absolute --show-toplevel)
	if [ "$#" != 1 ]; then
		echo "Expected 1 argument, but got $#."
		return 1
	fi
	if [ "$curr_worktree" = "$main_worktree" ]; then
		echo "Already in main worktree: $main_worktree"
		return 1
	fi

	(cd "$main_worktree" && git show-ignored "$1") | \
	while IFS= read -r l; do
		src="$curr_worktree/$l"
		dst="$main_worktree/$l"
	    # Skip files that are already linked
		if [ "$(readlink "$src")" = "$dst" ]; then
			info "$(orange "$src") already linked to $(blue "$dst"), skipping..."
			continue;
		fi
	    # Make sure file exists
		if [ ! -f "$dst" ] && [ ! -d "$dst" ] && [ ! -L "$dst" ]; then
			ln -s "$src" "$dst"
			success "Symlinked $(orange "$src") to $(blue "$dst")!"
			return
		fi
		error "Could not symlink $(orange "$src") to $(blue "$dst"); file exists!"
	done
}

# Used for the branches-touched command.
branches_touched() {
	default_branch="$2"
	git branch --format='%(refname:short)' | while read -r branch; do
		base="$(git merge-base "$branch" "$default_branch")"
		if git diff "$branch" "$base" | grep -q "a/$1"; then
			echo "$branch";
		fi
	done;
}

# Function used for the get-pr-target-branch script.
get_pr_target_branch () {
	PR_NUMBER="${1:-$(gh pr view --json number -q .number)}"
	# Ensure exit code of command is nonzero before proceeding
	CODE=$?
	if [ $CODE -eq 0 ]; then
		return $CODE
	fi
	gh api "repos/{owner}/{repo}/pulls/$PR_NUMBER"  --jq '"\(.base.repo.clone_url) \(.base.ref)"' \
   	| while read -r url branch; do
      remote=$(git remote -v | awk -v u="$url" '$2==u {print $1; exit}');
      echo "${remote}/${branch}";
    done

}

COMMAND="$1"
shift
$COMMAND "$@"
